

#### 标记-清除：

优点：



缺点：

1. 执行效果不稳定，当大多数对象为垃圾对象时，耗时较长
2. 导致内存碎片化，当程序无法分配较大对象时因为无法找到足够的连续内存而不得不提前进行下一次的垃圾回收

#### 标记-复制

优点：

1. 不存在内存碎片问题
2. 如果内存中的对象大多数是垃圾对象，则效率比较高，否则效率比较低



缺点：

1. 需要浪费一半的内存空间

使用：

hotspot虚拟机中Serial、ParNew等新生代收集器采用8:1:1的策略来设计新生代的内存布局

#### 标记-整理

让所有存活对象向内存的一端移动，直接清理掉边界以外的内存（需要重新设置对象的引用，所以需要Stop The World）

优点：

1. 不存在内存碎片化问题





**移动对象与不移动对象的对比：**

移动对象则内存回收时更复杂，不移动对象则内存分配时更复杂（因为有内存碎片）。从垃圾回收的角度来看，不移动对象停顿时间更短，但是从吞吐量来看，移动对象会更划算。

Parallel Scavenge更关注吞吐量，使用**标记-整理**算法

CMS更关注停顿时间，使用**标记-清理**算法（大多数时间容忍内存碎片的存在，直到内存的碎片化程度已经影响到分配对象时，再采用一次**标记-整理**算法收集一次）





Serial:标记-复制算法

Serial Old：标记-整理

ParNew：Serial的多线程版本，标记-复制算法，**只能与Serial Old和CM收集器配合使用**

Parallel Scavenge：标记-复制算法，与CMS更关注停顿时间不同，Parallel Scavenge的目标是达到一个可控制的吞吐量，吞吐量定义：CPU用于用户代码运行的时间/处理总消耗时间的比值。-XX:MaxGCPauseMillis,GC最大停顿时间，是以牺牲吞吐量和新生代空间为代价换取的（会把新生代调小一些）。-XX:GCTimeRatio垃圾收集时间比率，比如设置为19，则1/(1+19),允许的最大垃圾收集时间占总时间的95%





#### 对象动态年龄判定

为了更好的适应不同程序的内存状况，hotspot虚拟机并不是永远要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，如果Survivor空间中相同年龄的对象所占空间的总和超过Survivor的一半，年龄大于或等于这个年龄的对象可以直接进入老年代，无需等待MaxTenuringThreshold中要求的年龄。

####  空间分配担保

在发生MinorGC之前，JVM必须检查老年代的最大可用连续空间是否大于新生代对象的总大小，如果大于，则可以安全的执行Minor GC，否则，检查-XX:HandlePromotionFailure参数的设置值是否允许担保失败，如果允许，则检查老年代的最大可用连续空间是否大于历次Minor GC晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，尽管这次Minor GC是有风险的，如果小于或者XX:HandlePromotionFailure参数不允许担保失败，这时就会改为进行一次Full GC。

但是在JDK6 Update24之后，XX:HandlePromotionFailure参数不再影响JVM的空间分配担保机制。规则改为：只要老年代的连续空间大于新生代对象总大小或历次晋升的平均大小，就会进行Minor GC，否则，进行Full GC。

